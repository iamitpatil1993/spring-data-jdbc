/**
 * 
 */
package com.example.spring.data.jdbc.dao;

import java.util.List;

import javax.sql.DataSource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcOperations;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.jdbc.core.simple.SimpleJdbcInsertOperations;
import org.springframework.stereotype.Repository;

import com.example.spring.data.jdbc.dto.Actor;
import com.example.spring.data.jdbc.support.sqlquery.GetAllActorSqlQuery;
import com.example.spring.data.jdbc.support.sqlquery.UpdateActorSqlUpdate;

/**
 * THis class makes use of SimpleJdbcInsert class of spring-data-jdbc to
 * simplify insert statements in jdbc. This internally uses DataBase metadata
 * from driver to fetch column details of table by table name, and internally
 * creates the insert statemenent using detected columns.
 * 
 * We just need to specify table to which we want to per form insert and map of
 * column and their data.
 * 
 * @author amit
 *
 */
@Repository
public class JdbcActorDao implements ActorDao {

	private static final Logger LOGGER = LoggerFactory.getLogger(JdbcActorDao.class);
	private SimpleJdbcInsertOperations simpleJdbcInsertOperations;
	private static final String TABLE_NAME_ACTOR = "actor";
	private GetAllActorSqlQuery getAllActorQuery = null;
	private UpdateActorSqlUpdate updateActorSqlUpdate = null;
	private NamedParameterJdbcOperations namedParametersJdbcOperations = null; 
	

	@Autowired
	public JdbcActorDao(DataSource dataSource, NamedParameterJdbcOperations namedParametersJdbcOperations) {
		// This simpleJdbcInsert class is thread-safe class, so we can reuse same
		// instance for all concurrent call to singleton dao instance.
		// Note: Here we are just passing table name, it will read table metadata and
		// creates insert statement automatically.
		// We can specify specific columns as well to be only considered during insert
			// statement using usingGeneratedKeyColumns()
		simpleJdbcInsertOperations = new SimpleJdbcInsert(dataSource)
				.withTableName(TABLE_NAME_ACTOR) // specify name of table
				.usingGeneratedKeyColumns("id"); // specify name of auto-generated pk column.
		
		// Java object encapsulating Get all Actors JDBC query.
		// This Classes i.e SqlQuery and it's subclasses are thread-safe, so we can declare them at class level
		// and multiple threads can use same instances at a time.
		getAllActorQuery = new GetAllActorSqlQuery(dataSource);
		
		this.updateActorSqlUpdate = new UpdateActorSqlUpdate(dataSource);
		
		this.namedParametersJdbcOperations = namedParametersJdbcOperations; 
	}

	@Override
	public Actor add(Actor actor) {
		/*Map<String, String> insertValues = new HashMap<>(2);
		insertValues.put("first_name", actor.getFirstName());
		insertValues.put("last_name", actor.getLastName());*/
		
		// we can use SqlParameterSource interface and all it's implementations as well to specify query parameters.
		MapSqlParameterSource insertValues = new MapSqlParameterSource();
		insertValues.addValue("first_name", actor.getFirstName()).addValue("last_name", actor.getLastName());
		
		Number autoGeneratedPk =  simpleJdbcInsertOperations.executeAndReturnKey(insertValues);
		actor.setId(autoGeneratedPk.longValue());
		LOGGER.info("Actor created using SimpleJdbcInsert with auto-generated pk :: {}", actor.getId());
		return actor;
	}

	@Override
	public List<Actor> findAll() {
		return getAllActorQuery.execute();
	}

	@Override
	public void update(Actor actor) {
		int rowsUpdated = updateActorSqlUpdate.update(actor.getFirstName(), actor.getLastName(), actor.getId());
		LOGGER.info("Actor updated with id :: {}, rows Updated :: {}", actor.getId(), rowsUpdated);
	}

	/**
	 * Example to show, Passing in Lists of Values for IN Clause. 
	 */
	@Override
	public List<Actor> findAllByFirstNames(List<String> firstNames) {
		// we are passing List of primitive type as a sql argument.
		// NOTE: This feature, i.e to able to pass list as a sql parameter for IN claue can only be used with NamedParameterJdbcOperations.
		// because in case of positional parameters, we can't specify list as a posisitional parameter, and hence we need to create sql string dynamically usingiteration.
		// and setting sql parameters in IN clause manually.
		return namedParametersJdbcOperations.query(SqlStore.FIND_ALL_ACTOR_BY_FIRST_NAMES,
				new MapSqlParameterSource("firstNames", firstNames), new ActorRowMapper());
	}
}
